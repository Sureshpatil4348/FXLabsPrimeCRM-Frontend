import { NextResponse } from "next/server"
import { cookies } from "next/headers"
import { validateOrigin } from "@/lib/csrf"

// POST /api/create-partner
// Headers upstream:
// - Authorization: SUPABASE_PROJECT_ANON_KEY (includes Bearer prefix)
// - Admin-Token: value from cookie/header (no Bearer)
export async function POST(req: Request) {
  try {
    // Origin validation for state-changing requests
    const originError = validateOrigin(req)
    if (originError) return originError

    // Validate request body size (1MB limit for partner creation)
    const contentLength = req.headers.get('content-length')
    if (contentLength) {
      const sizeInBytes = parseInt(contentLength, 10)
      const maxSizeBytes = 1 * 1024 * 1024 // 1MB
      if (sizeInBytes > maxSizeBytes) {
        return NextResponse.json({ error: "Request body too large. Maximum size is 1MB." }, { status: 413 })
      }
    }

    const { full_name, email, commission_slabs } = (await req.json()) as {
      full_name?: string
      email?: string
      commission_slabs?: {
        slabs: Array<{
          from: number
          to: number | null
          commission: number
        }>
      }
    }

    //console.log('DEBUG: Received body:', { full_name, email, commission_slabs })
    //console.log('DEBUG: Commission slabs details:', JSON.stringify(commission_slabs, null, 2))

    // Password is autogenerated by the backend now, so we no longer accept or validate it here.
    if (!full_name || !email) {
      return NextResponse.json({ error: "Missing required fields: full_name and email" }, { status: 400 })
    }

    // Validate commission_slabs structure
    if (!commission_slabs || !commission_slabs.slabs || commission_slabs.slabs.length === 0) {
      return NextResponse.json({ error: "Commission slabs are required" }, { status: 400 })
    }

    // Validate slab values
    for (let i = 0; i < commission_slabs.slabs.length; i++) {
      const slab = commission_slabs.slabs[i]
      ////console.log(`DEBUG: Validating slab ${i + 1}:`, slab)
      
      if (typeof slab.from !== 'number' || slab.from < 0) {
        ////console.log(`DEBUG: Slab ${i + 1} failed: invalid 'from' value: ${slab.from}`)
        return NextResponse.json({ error: `Invalid 'from' value in slab ${i + 1}` }, { status: 400 })
      }
      
      if (slab.to !== null && (typeof slab.to !== 'number' || slab.to <= slab.from)) {
        ////console.log(`DEBUG: Slab ${i + 1} failed: invalid 'to' value: ${slab.to}`)
        return NextResponse.json({ error: `Invalid 'to' value in slab ${i + 1}` }, { status: 400 })
      }
      
      if (typeof slab.commission !== 'number' || slab.commission < 0 || slab.commission > 100) {
        //console.log(`DEBUG: Slab ${i + 1} failed: invalid commission: ${slab.commission}`)
        return NextResponse.json({ error: `Commission must be between 0 and 100 in slab ${i + 1}` }, { status: 400 })
      }
      
      // Validate contiguity (except for first slab)
      if (i > 0 && commission_slabs.slabs[i - 1].to !== null && (commission_slabs.slabs[i - 1].to as number) + 1 !== slab.from) {
        //console.log(`DEBUG: Slab ${i + 1} failed contiguity: prev.to=${commission_slabs.slabs[i - 1].to}, expected from=${(commission_slabs.slabs[i - 1].to as number) + 1}, actual from=${slab.from}`)
        return NextResponse.json({ error: `Slabs must be contiguous (gap at slab ${i + 1})` }, { status: 400 })
      }
    }

    //console.log('DEBUG: All slab validations passed')

    // Basic email format validation
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    if (!emailRegex.test(email)) {
      return NextResponse.json({ error: "Invalid email format" }, { status: 400 })
    }

    //console.log('DEBUG: Validation passed, preparing to send to upstream')

    const url =
      process.env.SUPABASE_CREATE_PARTNER_FUNCTION_URL

    if (!url) {
      return NextResponse.json({ error: "Server not configured: missing SUPABASE_CREATE_PARTNER_FUNCTION_URL" }, { status: 500 })
    }

    const anon = process.env.SUPABASE_PROJECT_ANON_KEY || process.env.NEXT_PUBLIC_SUPABASE_PROJECT_ANON_KEY || ""
    if (!anon) {
      return NextResponse.json({ error: "Server not configured: missing SUPABASE_PROJECT_ANON_KEY" }, { status: 500 })
    }

  const cookieStore = await cookies()
  const cookieAdmin = cookieStore.get("admin-token")?.value
  // Support header override if present
  const headerAdmin = req.headers.get("Admin-Token") || req.headers.get("x-admin-token") || ""
  const adminToken = headerAdmin || cookieAdmin || ""

    if (!adminToken) {
      return NextResponse.json({ error: "Unauthorized: missing admin token" }, { status: 401 })
    }

    const upstream = await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: anon,
        "Admin-Token": adminToken, // no Bearer prefix
      },
      // Do NOT send password - backend will autogenerate it
      body: JSON.stringify({ full_name, email, commission_slabs }),
    })

    //console.log('DEBUG: Sending to upstream:', { full_name, email, commission_slabs })

    if (!upstream.ok) {
      try {
        const err = await upstream.json()
        //console.log('DEBUG: Upstream error response:', err)
        // Backend returns error in err.error field, not err.message
        return NextResponse.json({ error: err?.error || "Failed to create partner" }, { status: upstream.status })
      } catch {
        //console.log('DEBUG: Failed to parse upstream error response')
        return NextResponse.json({ error: "Failed to create partner" }, { status: upstream.status })
      }
    }

    const data = await upstream.json()
    //console.log('DEBUG: Upstream success response:', data)
    // Expecting upstream to return: { message: "Partner <name> with Email - <email> has been created successfully" }
    return NextResponse.json(data)
  } catch (e) {
    return NextResponse.json({ error: "Unexpected server error" }, { status: 500 })
  }
}
